# CodeCraft-2019-Final
2019年华为软件精英挑战赛源代码，采用Floyd、模拟退火等算法，可调式单时间片发车数目。<br>
## 使用指南
1. TrainningMap,ExamMap分别对应训练赛地图以及正赛地图，地图主要包含car,cross,road三类文件，文件中数据格式的定义在CodeCraft-2019-TaskBook文档中有提及，两类地图的主要区别体现在车辆数目、路口标号（正赛中路口标号是无序的）；<br>
2. 解压CodeCraft-2019.rar文件，并在IDEA环境下打开（源码中需要改变地图文件的存储路径）；<br>
3. History.txt中记录了各个版本的主要改动内容，大概涵盖了我们小分队在半个月内的软挑思路变化；<br>
4. 我们学校在江山赛区，单张地图的初赛成绩大概在2200左右，这个分数勉强能搭上32强的末班车。<br>
## 2019年华为软挑经验汇总
在去年的“华为杯”数学建模比赛失利后，我开始关注华为软件精英挑战赛。期间在GitHub, CSDN等一些网站上了解到前几届华为软挑的赛题形式、题目内容和大佬们的比赛心得，本着“从别人的经历中学习成功经验”的态度，花了些时间去学习像模拟退火、遗传算法等一些高频算法，事实证明这在后期给我们提供了很多的思路。<br>
### 团队建设
华为软挑是团队竞赛，要求至多三人一组，编程语言限定在C/C++, Java, Python。我主学的Java，只是当时实验室的很多小伙伴去出差了，最后和分别学C++和Python的小伙伴组成一队，“劈里啪啦”，寓意代码敲的飞起，哈哈。俗话说“三人同心，其利断金”，单打独斗总是很孤独的，如果能和志同道合的队友集思广益，这段旅程会更加amazing。建议大家早些关注大赛，敲定队友，当然大家最好是主攻同一门语言，这确实能很大程度上提升后期的代码优化速度，降低比赛的诸多风险。
### 2019年软挑的赛程安排
1. 初赛的题目是在3月8号放出来的，3月15号软挑官网放出了两张训练地图，3月23号左右官网又放出了第三、第四张地图，3月30号晚10点关闭训练赛的跑分通道（到3月30号晚10点，应该说基本结束了训练赛的角逐，开始为3月31日的初赛正赛做铺垫），初赛正赛的比赛时间为3月31号09：00-17：00，总计8个小时。<br>
2. 3月8号-3月15号，这段时间华为已经公布了任务书和地图模板，其实这给了我们很长的组建队伍和分析题目的时间。事后想想，我们没能很好的利用这段时间crying。<br>
3. 3月23号左右的新地图的量级已经很接近正赛了，只是至此地图的路口标号仍是有序的，这也为后来我们花较长时间来进行代码解耦埋下了伏笔。<br>
### 心路——代码从无都有
1. 拿到题目后，一瞬间整个人是懵b的，这是什么题目？交通规则为什么这么复杂？我要实现什么，最终要提交什么？我是谁，在哪，为什么要参加这个比赛？整整两天时间我都在处在这一系列的灵魂拷问当中，这两天恰巧另外两个队友有事情请假回家，整个人毫无头绪又十分浮躁。现在想想，当时应该很多人在还没有进入真正去分析问题的环节，就已经放弃了。<br>
2. 追本溯源确实考验人们的耐心。忽略交通规则，重新分析问题后发现整个题目要解决的问题：在封闭式地图中，尽量保证所有车辆“自动行驶”到目的车库所用时间最短。我们要解决的问题其一是为每辆车规划最短路径，其二是合理确定发车数量/策略。接下来，就是伪代码-->代码的过程。<br>
3. 一个算法的实现，第一步就是数据的读取及预处理。Java的FileReader/FileWriter很方便，读进字符串流后，主要以Map<String, Integer>和Lit<Integer>的数据结构存储数据。<br>
4. 保证车辆最快入库，为车辆规划最优路径应该是能最先想到同时也能有力解决问题的一个思路。常见的最短路径算法有Dijkstra, A*, Bellman-Floyd等算法，对于训练赛的量级（万），单源的最短路径算法应当是非常耗费资源的（训练赛期间，要求单张地图的程序运行时间不超过300s，很多使用Python的选手都叫苦连天）。在综合考虑后，我们选择了Bellman-Floyd算法。利用邻接图的结构，产生最优路径的时间便消耗在二维数组的查询上，极大降低了时间复杂度。<br>
5. 在确定车辆路径后，最终文件的数据框架基本搭建完成了（大赛要求提交源代码，由华为云编译并运行，要求能产生满足答案格式的文本）。利用极简单的发车策略（事实证明，我们奉献了80%的时间在这部分的调参上，苦不堪言），我们第一次提交了代码（官网设置了100次/天的提交限制，并产生各个赛区的天梯图），在竞争不太激烈的江山赛区，2000+的分数排在了20名左右，整个初赛阶段我们基本维持在这个层次上（先不提最后的黑色三小时）。<br>
6. 在考虑车辆限速后，我们将邻接图的权重由道路长度改为车辆的行驶时间，满怀期待的第一次优化失败了，这也是之后无数次失败的开始（while(failed) 调试；）。这时问题主要集中在无法及时判断死锁，“主干道路”拥堵等问题。<br>
7. 期间官方组织了一次线上答疑活动，活动有很多爆料,包括开源判题器事件、按方向发车等策略。之后我们分别尝试了按东南西北四个方向发车、东南西北东北东南西北西南八个方向发车，在解决死锁问题上仍然没有建树，遂放弃该策略。<br>
8. 在不断试错后，事情有了**第一次转机**。我的队友提出修改较窄道路的权重，引导车辆选择较宽道路这一思路，进阶着就开始了紧锣密鼓的修改。我们依次尝试了幂函数和反比例的补偿函数，车辆的入库时间提升了400+！那一刻我们欢呼雀跃，一个小小的改动竟然产生了意想不到的效果，我们似乎真的感受到了华为“用代码改变世界”的理念。<br>
9. 在不断调试发车数量，更改补偿函数的系数过程中，我们大致确定了最优的参数。同时在测试过程中，我们发现一些道路的利用率极高，而另外一些道路则备受“冷落”，为了便于内部交流，我提出了“主干道路”这一概念，利用模拟退火的思想，通过“分流”（即舍弃一部分车辆使其选择较远的道路）来减缓主干道路压力，降低死锁的概率。事情有了**第二次转机**，车辆的入库时间再次提升了400+....<br>
10. 我们最后的优化思路：按车辆速度依次发车，避免慢车阻挡快车的现象。从死锁的位置看，这是一种十分有效的发车策略，但在缺少判题器这一核武器的加成下，我们将这中策略贯彻到底。这个时间点，在论坛和qq群中发现各个赛区的很多队伍已经按照赛题规则实现了自己的“判题器”。从理论上将，和官方完全一致的判题器可以完全避免死锁，从而产生理论上的最优值。受限于时间，我们没有去尝试这种做法，某种程度上已经接受了无法再进一步的局面。<br>
11. 黑色三小时：初赛的正赛在31号上午九点开始，下午五点停止提交代码。拿到地图那一刻，我傻眼了...之前峰峰老师有提醒我们注意解耦，在代码构建过程中我也有注意这一问题。可在后期我们将过多的精力花在调参上，没有从全局去审视自己的每个逻辑点。为了解决路口标号无序的问题，我们花费了三个小时去解决这一问题，这直接导致我们在最后没能按照最优参数来提交代码，惨遭滑铁卢~~最后要提醒大家一定要有全局意识，避免死磕和过多的纠结，在每个时间段完成相应的工作，才有可能获得比较理想的结果。<br>
